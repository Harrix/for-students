# 11 IT класс

## Python

- Установка Python: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/install-python/install-python.md>
- Установка PyCharm: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/install-pycharm/install-pycharm.md>
- Сложение двух чисел в Python IDLE: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-python-idle/add-2-num-python-idle.md>
- Сложение двух чисел в PyCharm: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-pycharm/add-2-num-pycharm.md>
- Сложение двух чисел в Python на онлайн сервисах: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-python-web/add-2-num-python-web.md>
- Сложение двух чисел в Wing Python IDE: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-wing/add-2-num-wing.md>
- Сложение двух чисел в Python через консоль и блокнот: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-python-console/add-2-num-python-console.md>
- Сложение двух чисел в Thonny на Python: <https://github.com/Harrix/harrix.dev-blog-2021/blob/main/add-2-num-thonny/add-2-num-thonny.md>

## Комментарии

Если мы хотим, чтобы какой-то кусок кода не выполнялся в нашей программе, то не обязательно его удалять. Можно просто его закомментировать через `#` или `""" """`:

```python
x = 2  # Это комментарий

# Это пример многострочного комментарий
# x = 3 Этот код не запустится
# Но его можно не удалять, а потом раскомментировать.

"""
Это тоже многострочный комментарий.
На самом деле это строчка текста, которая не приравнена ни к какой переменной.
Но исторически сложилось, что теперь это используют для комментариев.
Особенно для docstring, но об этом как-нибудь в другой раз.
"""

```

В PyCharm можно выделить код и нажать `Ctrl` + `/`, после чего код закомментируется.

## Арифметические операции

```python
a = 5
b = 2

c = a + b  # Сложение
print(c)  # 7

c = a - b  # Вычитание
print(c)  # 3

c = a * b  # Умножение
print(c)  # 3

c = a / b  # Деление
print(c)  # 2.5

c = a // b  # Целочисленное деление
print(c)  # 2 (2 целых и 1 в остатке)

c = a % b  # Остаток от деления
print(c)  # 1 (2 целых и 1 в остатке)

c = a ** b  # Возведение в степень
print(c)  # 25
```

Умножение выполняется первым по отношению к сложению. Поэтому, если нужно, не забываем расставлять скобки:

```python
print(2 + 2 * 2)  # 6
print((2 + 2) * 2)  # 8
```

На ноль делить нельзя:

```python
a = 5
b = 0
print(a / b) # ZeroDivisionError: division by zero
```

Для большего понимания темы посмотрите видео:

- [Деление нацело // и Деление по остатку % | Python с Нуля | Урок 7](https://www.youtube.com/watch?v=Du4Cz8Vy54o)
- [Урок 7 Деление нацело и деление по остатку Python](https://www.youtube.com/watch?v=RlfSygvBeZE)

## Название переменных

```python
# Хорошие названия переменных
a = 1
count_zero = 0  # в идеале названия переменных должны быть говорящими
_ = 2 # Например, в циклах используется for _ in range(5)
var2 = 3
MAX_HEIGHT = 200  # Для констант. То есть переменная больше не меняется

# Допустимые названия переменных
# Но так лучше не называть
A = 1
chislo__nulei = 0
_7jdj68 = 2
VaR2 = 3
countZero = 3
t_t52____kdkUU9_ = 3
countZERO = 0
переменная = 6
行列 = 101
min = 0  # Название переменной совпадает с функцией min

# А так нельзя называть
count zero = 6
2a = 6
42 = 43
var-2 = 9
var^2 = 6
v a r = 6
&var = 9
```

## Простые типы данных

```python
x = 5  # int - целые числа
second_var = 2.1  # float - вещественные числа
s = "Петя пришел домой."  # str - строки
b = True  # bool - логический тип данных (True, False)
n = None  # Отсутствие значения в переменной
```

Когда работаете с вещественными числами не забывайте, что нужно ставить точку, а не запятую:

```python
x = 5.1  # Правильно
x = 5,1  # Не правильно
```

## Вывод чисел в print

```python
x = 5
y = 2/3
print("x =", x, "y =", y)  # x = 5 y = 0.6666666666666666
print("x = " + str(x) + " y = " + str(y))  # x = 5 y = 0.6666666666666666
print("x = {} y = {}".format(x, y))  # x = 5 y = 0.6666666666666666
print("x = {} y = {:.3f}".format(x, y))  # x = 5 y = 0.667
print(f"x = {x} y = {y}")  # x = 5 y = 0.6666666666666666
print(f"x = {x} y = {y:.3f}")  # x = 5 y = 0.667
```

Запись `{:.3f}` означает, что выводится вещественное число и надо вывести три цифры после запятой по правилам округления.

## Преобразования типов данных

Тип данных выступает в роли функции, которая преобразует значение в указанный тип данных. Например, дан тип данных целых чисел `int`. Значит, функция `int()` будет превращать что-то в целые числа (например, `int(2.1)` вернет `2`).

```python
y = int(2.1)  # Значение: 2
y2 = int(True)  # Значение: 1
y3 = bool(1)  # Значение: True
```

```py
print(bool(10))  # Вывод: True
print(bool(-10))  # Вывод: True
print(bool("False"))  # Вывод: True
print(bool(""))  # Вывод: False
print(bool(None))  # Вывод: False
print(int(None))  # Вывод: TypeError: int() argument must be a string, a bytes-like object or a real number, not 'NoneType'
print(int("Петя"))  # Вывод: ValueError: invalid literal for int() with base 10: 'Петя'
print(int("78"))  # Вывод: 78
print(int(input()) + 1)  # Вывод: 78
```

`bool(0)`, `bool("")`, `bool(None)`, `bool(False)` дадут `False`. Остальные значения простых типов данных для `bool()` дадут `True`. На этом основана проверка пустой строки:

```python
if bool(s):
  ...
  # Строка s не пустая
if s:
  ...
  # Строка s не пустая
```

## Считывание чисел с консоли

```python
x = int(input()) # Считываем целое число
x2 = float(input()) # Считываем вещественное число
x3 = bool(input()) # Считываем булевское (логическое) значение: Так не делать!
x3 = bool(int(input())) # Считываем булевское значение: 0 или 1
```

Считать два числа, записанные в столбик:

```python
a = int(input())
b = int(input())
c = a + b
print(c)
```

Считать два числа в строчку:

```python
a, b = map(int, input().split())
c = a + b
print(c)
a, b = list(map(int, input().split())) # Иногда так лучше, например, с массивами
c = a + b
print(c)
```

## Пакет math

Пакет подключается строчкой `import math`.

Нужно посчитать синус 30 градусов:

```python
import math

y = math.sin(30)  # Неправильно, так как функция считает в радианах
y = math.sin(30 * math.pi / 180)  # Так правильно
y = math.sin(math.radians(30))  # Так еще лучше
print(y)  # 0.49999999999999994
# Обратите внимание на то, что ответ равен не строго 0.5
```

Нужно посчитать квадратный корень из 9:

```python
import math  # Не забудьте подключить библиотеку

x = 9
y = x ** 0.5  # Первый способ
y = math.sqrt(9)  # Второй способ
print(y)  # 3.0
```

## Задачи на арифметические операции

Нужно 3652 секунды перевести в часы, минуты, секунды:

```python
x = 3652
sec = x % 60  # Число секунд не может превышать 60
# Число минут не может превышать 60 в 1 часе (поэтому % 60)
# Но в минуте 60 секунд (поэтому // 60)
minutes = (x // 60) % 60
# Число часов будет целым числом
# Остаток уйдет в минуты и секунды
hour = x // (60 * 60)
print(hour, min, sec)
```

Вводится натуральное число. Если оно четное, то вывести 1, а если нечетное, то ноль. Условный оператор, тернарный оператор использовать нельзя:

```python
x = int(input())
print(1 - x % 2)  # 1 способ
print((x - 1) % 2)  # 2 способ
print(int(not (x % 2)))  # 3 способ
```

## Анализ строки `a, b = map(int, input().split())`

```python
x1 = input()
print(x1)  # x1 равен '2 3'. Вывод: 2 3
x2 = x1.split()  # Вывод: ['2', '3']
print(x2)
x3 = map(int, x2)  # Вывод: <map object at 0x00000244D5557F10>
print(x3)
# x4 = list(x3)  # Вывод: [2, 3]
# print(x4)
x4, x5 = x3  # Аналогично (x4, x5) или [x4, x5]
print(x4, x5)  # Вывод: 2 3
```

Команда `input()` считывает строчку с консоли.

Команда `.split()` — это метод любой строки, которая разбивает строку на массив кусочков. По умолчанию, разбивает по пробелу.

- `"2 3".split()` выдаст массив из двух элементов `['2', '3']`.
- `"12++78".split()` выдаст массив из одного элемента `['12++78']`.
- `"12++78".split("++")` выдаст массив из двух элементов `['12', '78']`.
- `"12;78; 4".split(";")` выдаст массив из трех элементов `['12', '78', ' 4']` (обратите внимание на пробел).

Так как `input()` возвращает строчку, то `input().split()` разобьет по пробелу введенную строку в консоли. Ввели `2 3`, получим список (массив) `['2', '3']`.

Функция `map()` применяет указанную функцию (в нашем случае это `int()`) к каждому элементу массива (например, `['2', '3']`). Но на самом деле в момент выполнения кода `map(int, ['2', '3'])` никаких преобразований с массивом не делает. Это некий «договор», «обязательства» по преобразованию массива. Поэтому `print(map(int, ['2', '3']))` выведет не массив чисел, а что-то вида `<map object at 0x00000244D5557F10>`. Зачем это нужно? Например, позволяет значительно экономить оперативную память во многих задачах, но об этом позже.

Можно «заставить» `map()` выполнить свои обязательства. Например, через `list()`: `list(map(int, ['2', '3']))`. В этом случае мы получим именно массив чисел `[2, 3]`.

Или вот таким образом: `a, b = map(int, ['2', '3'])`. На самом деле здесь опять идет преобразование в список (точнее в кортеж), и эта строчка аналогична следующему коду:

```python
t = tuple(map(int, ['2', '3']))
a = t[0]
b = t[1]
```

Кстати, а что такое `tuple` (кортеж)? Это просто неизменяемый список, в котором нельзя изменять значения элементов.

Посмотрите разницу:

```python
# Список list
t = [2, 3]
print(t[0])  # Вывод: 2
print(t[1])  # Вывод: 3
t[0] = 6
print(t[0])  # Вывод: 6
```

```python
# Кортеж tuple
t = (2, 3)
print(t[0])  # Вывод: 2
print(t[1])  # Вывод: 3
t[0] = 6  # Ошибка: TypeError: 'tuple' object does not support item assignment
```

Более подробно о функции `map()` можно прочитать [тут](https://www.digitalocean.com/community/tutorials/how-to-use-the-python-map-function-ru).

## Найти минимальное число из двух

Способ 1:

```python
x1, x2 = 26, 11

if x1 < x2:
    min_x = x1
else:
    min_x = x2

print(min_x)  # Вывод: 11
```

Способ 2:

```python
x1, x2 = 26, 11

min_x = x1
if x2 < min_x:
    min_x = x2

print(min_x)  # Вывод: 11
```

Способ 3 (с помощью [тернарного оператора](https://ru.code-basics.com/languages/python/lessons/ternary-operator)):

```python
x1, x2 = 26, 11

min_x = x1 if x1 < x2 else x2

print(min_x)  # Вывод: 11
```

Способ 4 (встроенный метод):

```python
x1, x2 = 26, 11

min_x = min(x1, x2)

print(min_x)  # Вывод: 11
```

## Задача на поиск максимального числа из минимальных

**Условие.** Даны две строки, в каждой из которых записано произвольное число целых чисел, разделенных `;`. В каждой строке найти минимальное число, а затем найти из этих минимальных чисел максимальное.

Пример выходных данных:

```text
45;8;12
96;74;4256;85
```

Вывод для примера: `74`.

**Решение.**

```python
x1, x2 = map(int, input().split(";"))
y1, y2 = map(int, input().split(";"))
min_x = min(x1, x2)
min_y = min(y1, y2)
max_min = max(min_x, min_y)
print(max_min)
```

Или в одну строку:

```python
print(max(min(map(int, input().split(";"))), min(map(int, input().split(";")))))
```

## Списки (массивы)

### Создание списка

```python
a = []  # Пустой список
a = list()  # Пустой список
a = [1, 5, 9, 10, -5]  # Заранее заданный список
```

### Вывод массива и обращение к элементам

```python
a = [1, 5, 9, 10]
print(a)  # Вывод массива: [1, 5, 9, 10]

# В квадратных скобках указывается номер элемента.
# Нумерация начинается с нуля
print(a[0])  # Вывод первого элемента массива: 1
a[0] = 6  # Изменение первого элемента массива
print(a[3])  # Вывод последнего элемента массива: 10
print(a[-1])  # Вывод последнего элемента массива (так лучше): 10

## При обращении к несуществующему элементу возникает ошибка
print(a[4])  # IndexError: list index out of range
```

### Срезы

```python
a = [1, 5, 9, 10]
print(a[1:])  # Вывод: [5, 9, 10]
print(a[1:3])  # Вывод: [5, 9]
print(a[1:-1])  # Вывод: [5, 9]
print(a[1::2])  # Вывод: [5, 10]
print(a[::-1])  # Перевернуть массив. Вывод: [10, 9, 5, 1]
```

Формула среза `a[b:e:s]`:

- `b`: С какого элемента по номеру (включительно) надо начинать срезать массив. Если не задано (например, `a[:2]`), то `b=0`, то есть начинаем с самого начала массива.
- `e`: Каким элементам по номеру (**не включительно**) надо завершить срез. Если не задано (например, `a[2:]`), то `e=len(a)` (длина массива), то есть копируем до конца массива.
- `s`: Шаг, с которым копируем элементы. Если не задано (например, `a[1:6:]`), то `s=1`. При `a[::2]` копируем каждый второй элемент.

Отсюда получается, что `a[::]` или `a[:]` равны `a[0:len(a):1]`.

По сути срез `a[::]` копирует массив, чем части и пользуются.

### Копирование массива

```python
a = [1, 5, 9, 10]

d = a.copy()  # 1 способ
d = a[::]  # 2 способ
d = a[:]  # 3 способ
```

Обратите внимание на то, что копировать `d = a` не стоит, так как в этом случае копируется ссылка на массив, а не сам массив, что приведет к тому, что две переменные `d` и `a` будут ссылаться на один и тот же массив. Сравните:

```python
a = [1, 5, 9, 10]
d = a
d[0] = 42
print(a)  # Вывод: [42, 5, 9, 10]
print(d)  # Вывод: [42, 5, 9, 10]

a = [1, 5, 9, 10]
d = a[::]
d[0] = 42
print(a)  # Вывод: [1, 5, 9, 10]
print(d)  # Вывод: [42, 5, 9, 10]
```

### Заполнение массива

Создать массив из 10 единичек:

```python
a = [1] * 10
print(a)  # Вывод: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```

Команда `a.append(x)` добавляет `x` в массив `a` (в его конец).

Заполнение натуральными числами

```python
# 1 способ
a = []
for i in range(1, 11):
    a.append(i)
print(a)  # Вывод: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 2 способ
a = [i for i in range(1, 11)]
print(a)  # Вывод: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### Длина массива

Через `len(a)`:

```python
a = [1, 5, 9, 10, -5]
print(len(a))  # Вывод: 5
```

### Обход элементов массива

```python
a = [1, 5, 9, 10, -5]

# 1 способ
for x in a:
    print(x)

# 2 способ
for i in range(len(a)):
    print(a[i])
```

Но будьте острожны. Если в массиве хранятся простые данные, то может произойти вот такое при использовании `for x in a`:

```python
a = [1, 5, 9, 10, -5]

for x in a:
    x = x + 1
    print(x)
print(a) # Вывод: [1, 5, 9, 10, -5]

for i in range(len(a)):
    a[i] = a[i] + 1
    print(a[i])
print(a) # Вывод: [2, 6, 10, 11, -4]
```

### Обход элементов массива в обратном порядке

```python
a = [1, 5, 9, 10, -5]

# 1 способ: расходуется лишняя память
for x in a[::-1]:
    print(x)

# 2 способ
for i in range(len(a)-1, -1, -1):
    print(a[i])

# 3 способ
for i in range(len(a)):
    print(a[len(a) - i - 1])
```

### Функции и методы

```python
a = [1, 5, 5, 10, -5]
print(min(a))  # Минимальный элемент. Вывод: -5
print(max(a))  # Максимальный элемент. Вывод: 10
print(len(a))  # Длина массива. Вывод: 5
print(a.count(5))  # Сколько раз 5 встречается в массиве. Вывод: 2
print(a.index(5))  # Номер, под которым встречается 5. Вывод: 1
print(a.index(55))  # Ошибка: ValueError: 55 is not in list
```

Если нужно находить элемент без получения ошибки, то можно так сделать:

```python
a = [1, 5, 5, 10, -5]
try:
    index_value = a.index(55)
except ValueError:
    index_value = -1

# Считаем, если элемент не найден, то возвращаем, например, -1.
print(index_value)  # Номер, под которым встречается 5. Вывод: -1
```

### Объединение массивов

```python
# 1 способ
a = [1, 5, 5, 10, -5]
b = [4, 6]
a.extend(b)
print(a)  # Вывод: [1, 5, 5, 10, -5, 4, 6]

# 2 способ
a = [1, 5, 5, 10, -5]
b = [4, 6]
a = a + b
print(a)  # Вывод: [1, 5, 5, 10, -5, 4, 6]
```

### Добавление, вставка и удаление элемента

```python
a = [4, 6]

# 1 способ
a = a + [5]
print(a)  # Вывод: [4, 6, 5]

# 2 способ
a.append(7)
print(a)  # Вывод: [4, 6, 5, 7]

# Вставка элемента в начало массива
a.insert(0, 66)
print(a)   # Вывод: [66, 4, 6, 5, 7]

# Удаление первого элемента массива
del a[0]
print(a)   # Вывод: [4, 6, 5, 7]
```

## ЕГЭ

### Задача ЕГЭ 15

Эту задачу почти всегда можно решить через перебор различных вариантов.

#### Координатная плоскость

[Задача 17382](https://inf-ege.sdamgia.ru/problem?id=17382). Для какого **наименьшего** целого неотрицательного числа A выражение

$$
(5x + 3y ≠ 60) ∨ ((A > x) ∧ (A > y))
$$

тождественно истинно при любых целых неотрицательных x и y?

**Решение**. Решаем с использованием перебора и «лакмусовой бумажки»:

```python
def f(x, y, A):
    return ((5 * x + 3 * y != 60) or ((A > x) and (A > y)))

for A in range (0, 100):
    b = True
    for x in range (0, 100):
        for y in range(0, 100):
            ff = f(x, y, A)
            if ff == False:
                b = False
    if b == True:
        print(A)
        break
```

Более короткое решение:

```python
for A in range(0, 100):
    b = True
    for x in range(0, 100):
        for y in range(0, 100):
            b = b and (((5 * x + 3 * y) != 60) or ((A > x) and (A > y)))
    if b:
        print(A)
        break
```
